Index: app/src/main/java/com/example/kakerlakenpoker/activities/PlayerIngameMainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kakerlakenpoker.activities;\r\n\r\nimport android.annotation.SuppressLint;\r\nimport android.app.Dialog;\r\nimport android.content.ClipData;\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.view.DragEvent;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\nimport android.widget.ArrayAdapter;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.Spinner;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.lifecycle.MutableLiveData;\r\n\r\n<<<<<<< HEAD:app/src/main/java/com/example/kakerlakenpoker/PlayerIngameMainActivity.java\r\nimport com.esotericsoftware.minlog.Log;\r\nimport com.example.kakerlakenpoker.card.Card;\r\nimport com.example.kakerlakenpoker.card.Type;\r\nimport com.example.kakerlakenpoker.game.Decision;\r\nimport com.example.kakerlakenpoker.game.Game;\r\nimport com.example.kakerlakenpoker.game.GameState;\r\nimport com.example.kakerlakenpoker.game.Turn;\r\nimport com.example.kakerlakenpoker.network.game.GameClient;\r\nimport com.example.kakerlakenpoker.player.Player;\r\n=======\r\nimport com.example.kakerlakenpoker.R;\r\nimport com.example.game.Game;\r\nimport com.example.game.player.Player;\r\n>>>>>>> reorderingFiles:app/src/main/java/com/example/kakerlakenpoker/activities/PlayerIngameMainActivity.java\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class PlayerIngameMainActivity extends AppCompatActivity {\r\n\r\n\r\n    LinearLayout dragViewKakerlake;\r\n    LinearLayout dragViewBat;\r\n    LinearLayout dragViewFly;\r\n    LinearLayout dragViewFrog;\r\n    LinearLayout dragViewRat;\r\n    LinearLayout dragViewScorpion;\r\n    LinearLayout dragViewSpider;\r\n    LinearLayout dragViewStink;\r\n\r\n    LinearLayout dropViewPlayer1;\r\n    LinearLayout popUp;\r\n    LinearLayout messageview;\r\n\r\n    Button sendChallange;\r\n    Button goBack;\r\n    EditText writeCardText;\r\n    Spinner choosePlayer;\r\n\r\n    //TextViews für die ausgabe der vorläufigen zahlen oder Nachrichten\r\n    TextView messageText;\r\n\r\n    TextView krötenView;\r\n    TextView spinnenView;\r\n    TextView fliegenView;\r\n    TextView scorpionView;\r\n    TextView kakerlakeView;\r\n    TextView ratteView;\r\n    TextView stinkwanzeView;\r\n    TextView fledermausView;\r\n\r\n\r\n    private String playedcard;\r\n    private String guessText;\r\n\r\n\r\n    List<String> namesOfPlayer = new ArrayList<String>();\r\n    Boolean check;\r\n    MutableLiveData<GameState> stateListen = new MutableLiveData<GameState>();\r\n    Player me = null;\r\n\r\n\r\n    @SuppressLint(\"ClickableViewAccessibility\")\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.player_ingameview);\r\n\r\n        me = getLocalPlayer();\r\n        me.getHandDeck().countAllCards();\r\n\r\n        messageText = (TextView) findViewById(R.id.messageText);\r\n\r\n        krötenView = (TextView) findViewById(R.id.krotenView);\r\n        spinnenView = findViewById(R.id.spinnenVIew);\r\n        fliegenView = findViewById(R.id.fliegeView);\r\n        scorpionView = findViewById(R.id.skorpionView);\r\n        kakerlakeView = findViewById(R.id.kakerlakenView);\r\n        ratteView = findViewById(R.id.rattenView);\r\n        fledermausView = findViewById(R.id.fledermausView);\r\n        stinkwanzeView = findViewById(R.id.stinkwanzeView);\r\n\r\n        displayCardAmounts();\r\n        checkTurn();\r\n\r\n\r\n        //init des popUp Fensters\r\n        messageview = (LinearLayout) findViewById(R.id.notificationView);\r\n        popUp = (LinearLayout)  findViewById(R.id.popupview);\r\n        messageview.setVisibility(View.INVISIBLE);\r\n        popUp.setVisibility(View.INVISIBLE);\r\n\r\n        //init der Buttons und Edit Text\r\n        sendChallange = (Button) findViewById(R.id.sendButton);\r\n        goBack = (Button) findViewById(R.id.exitButton);\r\n        writeCardText = (EditText) findViewById(R.id.guessText);\r\n\r\n        //init der KartenLayouts, Spinner(Wahl des Spielers) und der PlayerViews\r\n        dragViewKakerlake = (LinearLayout) findViewById(R.id.dragViewKakerlake);\r\n        dragViewBat = (LinearLayout) findViewById(R.id.dragViewBat);\r\n        dragViewFly = (LinearLayout) findViewById(R.id.dragViewFly);\r\n        dragViewFrog = (LinearLayout) findViewById(R.id.dragViewFrog);\r\n        dragViewRat = (LinearLayout) findViewById(R.id.dragViewRat);\r\n        dragViewScorpion = (LinearLayout) findViewById(R.id.dragViewScorpion);\r\n        dragViewSpider = (LinearLayout) findViewById(R.id.dragViewSpider);\r\n        dragViewStink = (LinearLayout) findViewById(R.id.dragViewStink);\r\n\r\n        dropViewPlayer1 = (LinearLayout) findViewById(R.id.Player1);\r\n        choosePlayer = (Spinner) findViewById(R.id.spinnerPlayer);\r\n\r\n        setUpSpinner();\r\n\r\n        //Hier wird die View touchable\r\n        dragViewKakerlake.setOnTouchListener(new TouchListener());\r\n        dragViewBat.setOnTouchListener(new TouchListener());\r\n        dragViewFly.setOnTouchListener(new TouchListener());\r\n        dragViewFrog.setOnTouchListener(new TouchListener());\r\n        dragViewRat.setOnTouchListener(new TouchListener());\r\n        dragViewScorpion.setOnTouchListener(new TouchListener());\r\n        dragViewSpider.setOnTouchListener(new TouchListener());\r\n        dragViewStink.setOnTouchListener(new TouchListener());\r\n\r\n        //Hier wird die Fläche, wo ein Object hineingezogen wird, aktiviert!\r\n        dropViewPlayer1.setOnDragListener(new DragListener());\r\n\r\n        //Buttons werden mit funktionen belegt. Back- PopUp Fenster wird geschlossen\r\n        goBack.setOnClickListener((View view)-> setInvisible(popUp));\r\n        sendChallange.setOnClickListener((View view)-> sendChallengeInputs());\r\n\r\n\r\n        //Observer, der bei Änderung des GameState die Activity neu ladet\r\n        stateListen.setValue(GameClient.getInstance().getGame().getCurrentState());\r\n        stateListen.observe(this, Observer -> {\r\n            displayCardAmounts();\r\n            checkTurn();\r\n        });\r\n\r\n\r\n    }\r\n\r\n    class DragListener implements View.OnDragListener{\r\n\r\n        @Override\r\n        public boolean onDrag(View v, DragEvent dragEvent) {\r\n            switch (dragEvent.getAction()) {\r\n\r\n                case DragEvent.ACTION_DRAG_STARTED:{\r\n                    View view = (View) dragEvent.getLocalState();\r\n                    playedcard = String.valueOf(view.getTag());\r\n                    break;}\r\n\r\n                case DragEvent.ACTION_DRAG_ENTERED:{\r\n                    break;}\r\n\r\n                case DragEvent.ACTION_DRAG_LOCATION:{\r\n\r\n                    break;}\r\n\r\n                case DragEvent.ACTION_DRAG_EXITED:{\r\n                    break;}\r\n\r\n                case DragEvent.ACTION_DRAG_ENDED:\r\n\r\n\r\n                case DragEvent.ACTION_DROP:{\r\n                    dropCorrect(dragEvent);\r\n                    return (true);}\r\n\r\n                default:{\r\n                    break;}\r\n            }\r\n            return true;\r\n        }\r\n\r\n        }\r\n\r\n    class TouchListener implements View.OnTouchListener{\r\n        @Override\r\n        public boolean onTouch(View view, MotionEvent event) {\r\n            if (event.getAction() == MotionEvent.ACTION_DOWN) {\r\n                ClipData data = ClipData.newPlainText(\"\", \"\");\r\n                View.DragShadowBuilder dragShadow = new View.DragShadowBuilder(view);\r\n                view.startDrag(data, dragShadow, view, 0);\r\n\r\n                return true;\r\n            }else {return false;}\r\n        }\r\n    }\r\n\r\n    public void dropCorrect(DragEvent de){\r\n\r\n        if(de.getResult() == true){\r\n            popUp.setVisibility(View.VISIBLE);\r\n        }\r\n        else{ popUp.setVisibility(View.INVISIBLE);}\r\n    }\r\n\r\n    public void setInvisible(LinearLayout linlayout){\r\n        linlayout.setVisibility(View.INVISIBLE);\r\n    }\r\n\r\n    public void setTextforResult(String result){\r\n        messageText.setText(result);\r\n        messageview.setVisibility(View.VISIBLE);\r\n    }\r\n\r\n    //hollt sich alle Namen der anderen Spieler und fügt die Namen in den Spinner!\r\n    public void setUpSpinner(){\r\n        for (Player player : GameClient.getInstance().getGame().getPlayers()){\r\n            if(!namesOfPlayer.contains(player.getName()) || !player.getID().equals(me.getID())){\r\n                namesOfPlayer.add(player.getID());\r\n            }\r\n\r\n        }\r\n        ArrayAdapter chooser = new ArrayAdapter(PlayerIngameMainActivity.this, android.R.layout.simple_spinner_dropdown_item, namesOfPlayer);\r\n        choosePlayer.setAdapter(chooser);\r\n    }\r\n    /*\r\n    Hier wird ein Spielzug (TURN) gemacht\r\n     */\r\n    public void sendChallengeInputs(){\r\n        checkEditTextInput();\r\n        if(check){\r\n            Turn turn;\r\n            Type selectedType = Type.valueOf(guessText);\r\n            Player enemy = null;\r\n            for(Player player: GameClient.getInstance().getGame().getPlayers()){\r\n                if(player.getID().equals(choosePlayer.getSelectedItem().toString()))\r\n                    enemy = player;\r\n            }\r\n            Card selectedCard = me.getHandDeck().findCard(playedcard);\r\n            turn = new Turn(selectedCard, selectedType,enemy);\r\n            GameClient.getInstance().getGame().makeTurn(me,turn);\r\n        this.popUp.setVisibility(View.INVISIBLE);\r\n        }\r\n    }\r\n    /*\r\n    Refresh the current view (doesent work!)\r\n     */\r\n    public void refreshView(){\r\n        Intent intent = getIntent();\r\n        finish();\r\n        startActivity(intent);\r\n    }\r\n\r\n    //Methode, die eine Decision (Truth/Lie) ausführt\r\n    public void decission(Decision decision){\r\n        GameClient.getInstance().getGame().makeDecision(me,decision);\r\n    }\r\n\r\n\r\n    public void checkEditTextInput(){\r\n\r\n        check = false;\r\n        String input = writeCardText.getText().toString().toUpperCase();\r\n\r\n        switch (input) {\r\n            case \"FLEDERMAUS\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"FLIEGE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"RATTE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"SCORPION\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"KAKERLAKE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"KROETE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"SPINNE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            case \"STINKWANZE\":\r\n                guessText = input;\r\n                check = true;\r\n                break;\r\n            default: writeCardText.setError(\"Falscher Type von Karte! Bitte gib eine richtige ein!\"); break;\r\n        }\r\n\r\n    }\r\n    //Gibt das Player Object des spielenden Client zurück\r\n    public Player getLocalPlayer() {\r\n        for (Player p : GameClient.getInstance().getGame().getPlayers()) {\r\n            if (p.getID().equals(String.valueOf(GameClient.getInstance().getClient().getClient().getID()))) {\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    Öffnet einen Dialog, wenn man eine Decision machen muss\r\n     */\r\n    public void showDialogeChallenge(){\r\n        Dialog dia = new Dialog(this);\r\n        dia.setContentView(R.layout.decision_dialoge);\r\n        dia.setCanceledOnTouchOutside(false);\r\n        TextView text = dia.findViewById(R.id.info);\r\n        Button buttonTruth = dia.findViewById(R.id.truth);\r\n        Button buttonLie = dia.findViewById(R.id.lie);\r\n        dia.show();\r\n        buttonTruth.setOnClickListener(view -> {\r\n            decission(Decision.TRUTH);\r\n            dia.dismiss();\r\n        });\r\n\r\n        buttonLie.setOnClickListener(view -> {\r\n            decission(Decision.LIE);\r\n            dia.dismiss();\r\n        });\r\n\r\n        text.setText(\"Player: \" + GameClient.getInstance().getGame().getCurrentPlayer().getName() + \" played: \" + GameClient.getInstance().getGame().getTurn().getSelectedType().toString());\r\n\r\n    }\r\n\r\n    /*\r\n    Wird geöffnet, wenn man nicht an der Reihe ist\r\n     */\r\n    public void showDialogeWait(){\r\n        Dialog dia = new Dialog(this);\r\n        dia.setContentView(R.layout.waiting_dialoge);\r\n        dia.setCanceledOnTouchOutside(false);\r\n        TextView text = dia.findViewById(R.id.notYoutTurn);\r\n        text.setText(\"Player: \" + GameClient.getInstance().getGame().getCurrentPlayer().getName() + \" turn!\");\r\n        dia.show();\r\n\r\n    }\r\n        //möchte man den Stand verändern (Display), ruft man diese Klasse auf.\r\n        public void updateTheCollectedCards () {\r\n            krötenView.setText(me.getCollectedDeck().getKroete());\r\n            spinnenView.setText(me.getCollectedDeck().getSpinne());\r\n            fliegenView.setText(me.getCollectedDeck().getFliege());\r\n            scorpionView.setText(me.getCollectedDeck().getScorpion());\r\n            kakerlakeView.setText(me.getCollectedDeck().getKakerlake());\r\n            ratteView.setText(me.getCollectedDeck().getRatte());\r\n            stinkwanzeView.setText(me.getCollectedDeck().getStinkwanze());\r\n            fledermausView.setText(me.getCollectedDeck().getFledermaus());\r\n        }\r\n\r\n        //zeigt die gesammelten Karten der Gegner\r\n        public void showEnemyCollectCards(){\r\n        String output = \"\";\r\n\r\n        for(Player all : GameClient.getInstance().getGame().getPlayers()){\r\n\r\n            //hier soll die ausgaben meiner karten verhindert werden.\r\n            if(all == me){\r\n            }\r\n            else{ output += all.getCollectedDeck().toString() + (\"\\n\");}\r\n        }\r\n        messageText.setText(output);\r\n        messageview.setVisibility(View.VISIBLE);\r\n        }\r\n\r\n        public void displayCardAmounts(){\r\n            krötenView.setText(me.getHandDeck().getKroete());\r\n            spinnenView.setText(me.getHandDeck().getSpinne());\r\n            fliegenView.setText(me.getHandDeck().getFliege());\r\n            scorpionView.setText(me.getHandDeck().getScorpion());\r\n            kakerlakeView.setText(me.getHandDeck().getKakerlake());\r\n            ratteView.setText(me.getHandDeck().getRatte());\r\n            fledermausView.setText(me.getHandDeck().getFledermaus());\r\n            stinkwanzeView.setText(me.getHandDeck().getStinkwanze());\r\n        }\r\n\r\n        public void checkTurn(){\r\n            //me ist nicht aktuell am Spiel beteiligt\r\n            if(!me.getID().equals(GameClient.getInstance().getGame().getCurrentPlayer().getID()) || !me.getID().equals(GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getID())){\r\n                Log.debug(\"Not your turn!\");\r\n                Log.debug(\"Current Player: \" + GameClient.getInstance().getGame().getCurrentPlayer().getName());\r\n                Log.debug(\"Current Enems: \" + GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getName());\r\n                showDialogeWait();\r\n            }\r\n\r\n            //Turn wurde ausgeführt und me wurde als Enemy ausgewählt\r\n            if(GameClient.getInstance().getGame().getCurrentState() == GameState.AWAITING_DECISION && !GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getID().equals(me.getID())){\r\n                Log.debug(\"Current Player: \" + GameClient.getInstance().getGame().getCurrentPlayer().getName());\r\n                Log.debug(\"Current Enems: \" + GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getName());\r\n                Log.debug(\"You have to make a decission!\");\r\n                showDialogeChallenge();\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/kakerlakenpoker/activities/PlayerIngameMainActivity.java	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/java/com/example/kakerlakenpoker/activities/PlayerIngameMainActivity.java	(date 1623529225821)
@@ -1,44 +1,50 @@
 package com.example.kakerlakenpoker.activities;
 
 import android.annotation.SuppressLint;
+import android.app.AlertDialog;
 import android.app.Dialog;
 import android.content.ClipData;
 import android.content.Intent;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
 import android.os.Bundle;
 import android.view.DragEvent;
 import android.view.MotionEvent;
 import android.view.View;
 import android.widget.ArrayAdapter;
 import android.widget.Button;
+import android.widget.CheckBox;
 import android.widget.EditText;
 import android.widget.LinearLayout;
 import android.widget.Spinner;
 import android.widget.TextView;
+import android.widget.Toast;
 
 import androidx.appcompat.app.AppCompatActivity;
 import androidx.lifecycle.MutableLiveData;
 
-<<<<<<< HEAD:app/src/main/java/com/example/kakerlakenpoker/PlayerIngameMainActivity.java
 import com.esotericsoftware.minlog.Log;
-import com.example.kakerlakenpoker.card.Card;
-import com.example.kakerlakenpoker.card.Type;
-import com.example.kakerlakenpoker.game.Decision;
-import com.example.kakerlakenpoker.game.Game;
-import com.example.kakerlakenpoker.game.GameState;
-import com.example.kakerlakenpoker.game.Turn;
-import com.example.kakerlakenpoker.network.game.GameClient;
-import com.example.kakerlakenpoker.player.Player;
-=======
+import com.example.game.Decision;
+import com.example.game.GameState;
+import com.example.game.Turn;
+import com.example.game.card.Card;
+import com.example.game.card.Type;
+import com.example.game.listener.StateListener;
+import com.example.game.player.CollectedDeck;
+import com.example.game.player.PlayerState;
 import com.example.kakerlakenpoker.R;
-import com.example.game.Game;
 import com.example.game.player.Player;
->>>>>>> reorderingFiles:app/src/main/java/com/example/kakerlakenpoker/activities/PlayerIngameMainActivity.java
+import com.example.server.network.dto.clienttogameserver.HandOver;
 
+import java.text.CollationElementIterator;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
-public class PlayerIngameMainActivity extends AppCompatActivity {
+public class PlayerIngameMainActivity extends AppCompatActivity implements SensorEventListener{
 
 
     LinearLayout dragViewKakerlake;
@@ -58,7 +64,8 @@
     Button goBack;
     EditText writeCardText;
     Spinner choosePlayer;
-
+    Spinner types;
+    ArrayList<Type> typeList;
     //TextViews für die ausgabe der vorläufigen zahlen oder Nachrichten
     TextView messageText;
 
@@ -74,41 +81,57 @@
 
     private String playedcard;
     private String guessText;
-
+    Dialog diaWait;
+    Dialog diaDecision;
+    private AlertDialog alertDialog;
+    private TextView waitingDialogTextView;
 
     List<String> namesOfPlayer = new ArrayList<String>();
     Boolean check;
     MutableLiveData<GameState> stateListen = new MutableLiveData<GameState>();
     Player me = null;
 
+    //Werte für den Handy-Shake
+    private CheckBox cheatbox;
+    private Sensor accelerometer;
+    private SensorManager ShakeSensorManager;
+    private float wert1;
+    private float wert2;
+    private float wert3;
+    Boolean erlaubnis = false;
+
 
     @SuppressLint("ClickableViewAccessibility")
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.player_ingameview);
-
+        diaDecision = new Dialog(this);
+        diaWait = new Dialog(this);
         me = getLocalPlayer();
         me.getHandDeck().countAllCards();
 
+
         messageText = (TextView) findViewById(R.id.messageText);
 
-        krötenView = (TextView) findViewById(R.id.krotenView);
-        spinnenView = findViewById(R.id.spinnenVIew);
-        fliegenView = findViewById(R.id.fliegeView);
-        scorpionView = findViewById(R.id.skorpionView);
-        kakerlakeView = findViewById(R.id.kakerlakenView);
-        ratteView = findViewById(R.id.rattenView);
-        fledermausView = findViewById(R.id.fledermausView);
-        stinkwanzeView = findViewById(R.id.stinkwanzeView);
+        krötenView = (TextView) findViewById(R.id.kakerlakenView);
+        spinnenView = findViewById(R.id.fliegeView);
+        fliegenView = findViewById(R.id.rattenView);
+        scorpionView = findViewById(R.id.stinkwanzeView);
+        kakerlakeView = findViewById(R.id.fledermausView);
+        ratteView = findViewById(R.id.spinnenVIew);
+        fledermausView = findViewById(R.id.skorpionView);
+        stinkwanzeView = findViewById(R.id.krotenView);
 
         displayCardAmounts();
+        initializeDialogs();
         checkTurn();
 
 
+
         //init des popUp Fensters
         messageview = (LinearLayout) findViewById(R.id.notificationView);
-        popUp = (LinearLayout)  findViewById(R.id.popupview);
+        popUp = (LinearLayout) findViewById(R.id.popupview);
         messageview.setVisibility(View.INVISIBLE);
         popUp.setVisibility(View.INVISIBLE);
 
@@ -146,57 +169,84 @@
         dropViewPlayer1.setOnDragListener(new DragListener());
 
         //Buttons werden mit funktionen belegt. Back- PopUp Fenster wird geschlossen
-        goBack.setOnClickListener((View view)-> setInvisible(popUp));
-        sendChallange.setOnClickListener((View view)-> sendChallengeInputs());
+        goBack.setOnClickListener((View view) -> setInvisible(popUp));
+        sendChallange.setOnClickListener((View view) -> sendChallengeInputs());
 
+        GameClient.getInstance().getGame().setStateListener(new StateListenerImpl());
+
+        //Init SensorManger
+        ShakeSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
 
         //Observer, der bei Änderung des GameState die Activity neu ladet
         stateListen.setValue(GameClient.getInstance().getGame().getCurrentState());
         stateListen.observe(this, Observer -> {
-            displayCardAmounts();
-            checkTurn();
+
+        });
+
+        //Handling und init für den Cheat
+        cheatbox = (CheckBox) findViewById(R.id.checkBox);
+        ShakeSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        accelerometer = ShakeSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+
+        cheatbox.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                Toast.makeText(getApplicationContext(), "Bitte Handy schütteln!!!", Toast.LENGTH_SHORT).show();
+                erlaubnis = true;
+            }
         });
 
+
+    }
+
+    @Override
+    public void onPointerCaptureChanged(boolean hasCapture) {
 
     }
 
-    class DragListener implements View.OnDragListener{
+    class DragListener implements View.OnDragListener {
 
         @Override
         public boolean onDrag(View v, DragEvent dragEvent) {
             switch (dragEvent.getAction()) {
 
-                case DragEvent.ACTION_DRAG_STARTED:{
+                case DragEvent.ACTION_DRAG_STARTED: {
                     View view = (View) dragEvent.getLocalState();
                     playedcard = String.valueOf(view.getTag());
-                    break;}
+                    break;
+                }
 
-                case DragEvent.ACTION_DRAG_ENTERED:{
-                    break;}
+                case DragEvent.ACTION_DRAG_ENTERED: {
+                    break;
+                }
 
-                case DragEvent.ACTION_DRAG_LOCATION:{
+                case DragEvent.ACTION_DRAG_LOCATION: {
 
-                    break;}
+                    break;
+                }
 
-                case DragEvent.ACTION_DRAG_EXITED:{
-                    break;}
+                case DragEvent.ACTION_DRAG_EXITED: {
+                    break;
+                }
 
                 case DragEvent.ACTION_DRAG_ENDED:
 
 
-                case DragEvent.ACTION_DROP:{
+                case DragEvent.ACTION_DROP: {
                     dropCorrect(dragEvent);
-                    return (true);}
+                    return (true);
+                }
 
-                default:{
-                    break;}
+                default: {
+                    break;
+                }
             }
             return true;
         }
 
-        }
+    }
 
-    class TouchListener implements View.OnTouchListener{
+    class TouchListener implements View.OnTouchListener {
         @Override
         public boolean onTouch(View view, MotionEvent event) {
             if (event.getAction() == MotionEvent.ACTION_DOWN) {
@@ -205,73 +255,83 @@
                 view.startDrag(data, dragShadow, view, 0);
 
                 return true;
-            }else {return false;}
+            } else {
+                return false;
+            }
         }
     }
 
-    public void dropCorrect(DragEvent de){
+    public void dropCorrect(DragEvent de) {
 
-        if(de.getResult() == true){
+        if (de.getResult() == true) {
             popUp.setVisibility(View.VISIBLE);
+        } else {
+            popUp.setVisibility(View.INVISIBLE);
         }
-        else{ popUp.setVisibility(View.INVISIBLE);}
     }
 
-    public void setInvisible(LinearLayout linlayout){
+    public void setInvisible(LinearLayout linlayout) {
         linlayout.setVisibility(View.INVISIBLE);
     }
 
-    public void setTextforResult(String result){
+    public void setTextforResult(String result) {
         messageText.setText(result);
         messageview.setVisibility(View.VISIBLE);
     }
 
     //hollt sich alle Namen der anderen Spieler und fügt die Namen in den Spinner!
-    public void setUpSpinner(){
-        for (Player player : GameClient.getInstance().getGame().getPlayers()){
-            if(!namesOfPlayer.contains(player.getName()) || !player.getID().equals(me.getID())){
-                namesOfPlayer.add(player.getID());
+    public void setUpSpinner() {
+        for (Player player : GameClient.getInstance().getGame().getPlayers()) {
+            if (!(player.getId() == me.getId())) {
+                namesOfPlayer.add(String.valueOf(player.getId()));
             }
 
         }
         ArrayAdapter chooser = new ArrayAdapter(PlayerIngameMainActivity.this, android.R.layout.simple_spinner_dropdown_item, namesOfPlayer);
         choosePlayer.setAdapter(chooser);
     }
+
     /*
     Hier wird ein Spielzug (TURN) gemacht
      */
-    public void sendChallengeInputs(){
+    public void sendChallengeInputs() {
         checkEditTextInput();
-        if(check){
+        if (check) {
             Turn turn;
             Type selectedType = Type.valueOf(guessText);
             Player enemy = null;
-            for(Player player: GameClient.getInstance().getGame().getPlayers()){
-                if(player.getID().equals(choosePlayer.getSelectedItem().toString()))
+            for (Player player : GameClient.getInstance().getGame().getPlayers()) {
+                if (player.getId() == Integer.parseInt(choosePlayer.getSelectedItem().toString()))
                     enemy = player;
             }
+            assert enemy != null;
+            Log.info("This is the selected enemy: " + enemy.getId());
+
             Card selectedCard = me.getHandDeck().findCard(playedcard);
-            turn = new Turn(selectedCard, selectedType,enemy);
-            GameClient.getInstance().getGame().makeTurn(me,turn);
-        this.popUp.setVisibility(View.INVISIBLE);
+            Log.info("selected things", selectedType + " " + selectedCard + " " + enemy.getId());
+            turn = new Turn(selectedCard, selectedType, enemy);
+            GameClient.getInstance().getGame().getCurrentPlayer().getHandDeck().removeCard(selectedCard);
+            GameClient.getInstance().getGame().makeTurn(me, turn);
+            this.popUp.setVisibility(View.INVISIBLE);
         }
     }
+
     /*
     Refresh the current view (doesent work!)
      */
-    public void refreshView(){
+    public void refreshView() {
         Intent intent = getIntent();
         finish();
         startActivity(intent);
     }
 
     //Methode, die eine Decision (Truth/Lie) ausführt
-    public void decission(Decision decision){
-        GameClient.getInstance().getGame().makeDecision(me,decision);
+    public void decission(Decision decision) {
+        GameClient.getInstance().getGame().makeDecision(me, decision);
     }
 
 
-    public void checkEditTextInput(){
+    public void checkEditTextInput() {
 
         check = false;
         String input = writeCardText.getText().toString().toUpperCase();
@@ -309,14 +369,19 @@
                 guessText = input;
                 check = true;
                 break;
-            default: writeCardText.setError("Falscher Type von Karte! Bitte gib eine richtige ein!"); break;
+            default:
+                writeCardText.setError("Falscher Type von Karte! Bitte gib eine richtige ein!");
+                break;
         }
 
     }
+
     //Gibt das Player Object des spielenden Client zurück
     public Player getLocalPlayer() {
         for (Player p : GameClient.getInstance().getGame().getPlayers()) {
-            if (p.getID().equals(String.valueOf(GameClient.getInstance().getClient().getClient().getID()))) {
+            Log.info("This is the players id", String.valueOf(p.getId()));
+            Log.info("This is my id", String.valueOf(GameClient.getInstance().getClient().getClient().getID()));
+            if (p.getId() == GameClient.getInstance().getClient().getClient().getID()) {
                 return p;
             }
         }
@@ -326,97 +391,322 @@
     /*
     Öffnet einen Dialog, wenn man eine Decision machen muss
      */
-    public void showDialogeChallenge(){
-        Dialog dia = new Dialog(this);
-        dia.setContentView(R.layout.decision_dialoge);
-        dia.setCanceledOnTouchOutside(false);
-        TextView text = dia.findViewById(R.id.info);
-        Button buttonTruth = dia.findViewById(R.id.truth);
-        Button buttonLie = dia.findViewById(R.id.lie);
-        dia.show();
+    public void showDialogeChallenge() {
+        diaDecision = new Dialog(this);
+        View view1 = View.inflate(this, R.layout.decision_dialoge, null);
+        setUpTypesSpinner(view1);
+        diaDecision.setContentView(view1);
+        diaDecision.setCanceledOnTouchOutside(false);
+        Toast myToast = new Toast(this);
+        String selectedCard = GameClient.getInstance().getGame().getTurn().getSelectedCard().getType().toString();
+        String chosenTyp = GameClient.getInstance().getGame().getTurn().getSelectedType().toString();
+        int player = GameClient.getInstance().getGame().getCurrentPlayer().getId();
+        int enemy = GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getId();
+        TextView text = diaDecision.findViewById(R.id.info);
+        Button buttonTruth = diaDecision.findViewById(R.id.truth);
+        Button buttonLie = diaDecision.findViewById(R.id.lie);
+        Button buttonHandOver = diaDecision.findViewById(R.id.handOverButton);
+        Spinner spinner = view1.findViewById(R.id.handOver);
+        ArrayList<String> list = new ArrayList<>();
+        for (Player player1 : GameClient.getInstance().getGame().getPlayers()) {
+            if (!(player1.getId() == me.getId()) && player1.getState() != PlayerState.PLAYED) {
+                list.add(String.valueOf(player1.getId()));
+            }
+        }
+
+        ArrayAdapter adapter = new ArrayAdapter(PlayerIngameMainActivity.this, android.R.layout.simple_spinner_dropdown_item, list);
+        spinner.setAdapter(adapter);
+        diaDecision.show();
+        myToast.setDuration(Toast.LENGTH_LONG);
+
         buttonTruth.setOnClickListener(view -> {
+            Toast toast = Toast.makeText(this, "Player: " + player + " played: " + selectedCard + " and said: " + chosenTyp + "and you said TRUTH", Toast.LENGTH_LONG);
+            toast.show();
             decission(Decision.TRUTH);
-            dia.dismiss();
+            diaDecision.dismiss();
         });
 
         buttonLie.setOnClickListener(view -> {
+            Toast toast = Toast.makeText(this, "Player: " + player + " played: " + selectedCard + " and said: " + chosenTyp + "and you said LIE", Toast.LENGTH_LONG);
+            toast.show();
             decission(Decision.LIE);
-            dia.dismiss();
+            diaDecision.dismiss();
+        });
+
+        buttonHandOver.setOnClickListener(view -> {
+
+            Player ene = null;
+            for (Player p : GameClient.getInstance().getGame().getPlayers()) {
+                if (p.getId() == Integer.parseInt(spinner.getSelectedItem().toString())) ;
+                ene = p;
+            }
+            Card card = GameClient.getInstance().getGame().getTurn().getSelectedCard();
+            assert ene != null;
+            Log.info("selected things", selectedCard + " " + card + " " + ene.getId());
+            GameClient.getInstance().getGame().handOver(me, new HandOver(ene,Decision.TRUTH));
+
         });
 
-        text.setText("Player: " + GameClient.getInstance().getGame().getCurrentPlayer().getName() + " played: " + GameClient.getInstance().getGame().getTurn().getSelectedType().toString());
 
+        String myText = "Player: " + GameClient.getInstance().getGame().getCurrentPlayer().getId() + " says " + GameClient.getInstance().getGame().getTurn().getSelectedType().toString();
+        text.setText(myText);
     }
 
     /*
     Wird geöffnet, wenn man nicht an der Reihe ist
      */
-    public void showDialogeWait(){
+    public void showDialogeWait() {
+        String myString = "Players: " + GameClient.getInstance().getGame().getCurrentPlayer().getId() + " turn!";
+        waitingDialogTextView.setText(myString);
+        alertDialog.show();
+    }
+
+    /*
+    Wird geöffnet, wenn das Spiel vorbei ist
+     */
+    public void showDialogeGameOver() {
         Dialog dia = new Dialog(this);
-        dia.setContentView(R.layout.waiting_dialoge);
+        dia.setContentView(R.layout.game_over_dialoge);
         dia.setCanceledOnTouchOutside(false);
-        TextView text = dia.findViewById(R.id.notYoutTurn);
-        text.setText("Player: " + GameClient.getInstance().getGame().getCurrentPlayer().getName() + " turn!");
+        TextView text = dia.findViewById(R.id.textGameOver);
+        int lostPlayer = GameClient.getInstance().getGame().getCurrentPlayer().getId();
+        if (me.getId() == lostPlayer) {
+            String lost = "You lost the game!";
+            text.setText(lost);
+        } else {
+            String won = "You won the game and player: " + lostPlayer + " lost!";
+            text.setText(won);
+        }
         dia.show();
-
     }
-        //möchte man den Stand verändern (Display), ruft man diese Klasse auf.
-        public void updateTheCollectedCards () {
-            krötenView.setText(me.getCollectedDeck().getKroete());
-            spinnenView.setText(me.getCollectedDeck().getSpinne());
-            fliegenView.setText(me.getCollectedDeck().getFliege());
-            scorpionView.setText(me.getCollectedDeck().getScorpion());
-            kakerlakeView.setText(me.getCollectedDeck().getKakerlake());
-            ratteView.setText(me.getCollectedDeck().getRatte());
-            stinkwanzeView.setText(me.getCollectedDeck().getStinkwanze());
-            fledermausView.setText(me.getCollectedDeck().getFledermaus());
-        }
+
+    //möchte man den Stand verändern (Display), ruft man diese Klasse auf.
+    public void updateTheCollectedCards() {
+        krötenView.setText(me.getCollectedDeck().getKroete());
+        spinnenView.setText(me.getCollectedDeck().getSpinne());
+        fliegenView.setText(me.getCollectedDeck().getFliege());
+        scorpionView.setText(me.getCollectedDeck().getScorpion());
+        kakerlakeView.setText(me.getCollectedDeck().getKakerlake());
+        ratteView.setText(me.getCollectedDeck().getRatte());
+        stinkwanzeView.setText(me.getCollectedDeck().getStinkwanze());
+        fledermausView.setText(me.getCollectedDeck().getFledermaus());
+    }
 
-        //zeigt die gesammelten Karten der Gegner
-        public void showEnemyCollectCards(){
+    //zeigt die gesammelten Karten der Gegner
+    public void showEnemyCollectCards() {
         String output = "";
 
-        for(Player all : GameClient.getInstance().getGame().getPlayers()){
+        for (Player all : GameClient.getInstance().getGame().getPlayers()) {
 
             //hier soll die ausgaben meiner karten verhindert werden.
-            if(all == me){
+            if (all == me) {
+            } else {
+                output += all.getCollectedDeck().toString() + ("\n");
             }
-            else{ output += all.getCollectedDeck().toString() + ("\n");}
         }
         messageText.setText(output);
         messageview.setVisibility(View.VISIBLE);
-        }
+    }
 
-        public void displayCardAmounts(){
-            krötenView.setText(me.getHandDeck().getKroete());
-            spinnenView.setText(me.getHandDeck().getSpinne());
-            fliegenView.setText(me.getHandDeck().getFliege());
-            scorpionView.setText(me.getHandDeck().getScorpion());
-            kakerlakeView.setText(me.getHandDeck().getKakerlake());
-            ratteView.setText(me.getHandDeck().getRatte());
-            fledermausView.setText(me.getHandDeck().getFledermaus());
-            stinkwanzeView.setText(me.getHandDeck().getStinkwanze());
-        }
+    public void displayCardAmounts() {
+        krötenView.setText(String.valueOf(me.getHandDeck().getKroete()));
+        spinnenView.setText(String.valueOf(me.getHandDeck().getSpinne()));
+        fliegenView.setText(String.valueOf(me.getHandDeck().getFliege()));
+        scorpionView.setText(String.valueOf(me.getHandDeck().getScorpion()));
+        kakerlakeView.setText(String.valueOf(me.getHandDeck().getKakerlake()));
+        ratteView.setText(String.valueOf(me.getHandDeck().getRatte()));
+        fledermausView.setText(String.valueOf(me.getHandDeck().getFledermaus()));
+        stinkwanzeView.setText(String.valueOf(me.getHandDeck().getStinkwanze()));
+
+        krötenView.invalidate();
+        spinnenView.invalidate();
+        fliegenView.invalidate();
+        scorpionView.invalidate();
+        kakerlakeView.invalidate();
+        ratteView.invalidate();
+        fledermausView.invalidate();
+        stinkwanzeView.invalidate();
+    }
 
-        public void checkTurn(){
-            //me ist nicht aktuell am Spiel beteiligt
-            if(!me.getID().equals(GameClient.getInstance().getGame().getCurrentPlayer().getID()) || !me.getID().equals(GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getID())){
-                Log.debug("Not your turn!");
-                Log.debug("Current Player: " + GameClient.getInstance().getGame().getCurrentPlayer().getName());
-                Log.debug("Current Enems: " + GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getName());
+    public void checkTurn() {
+        Log.info("The turn is checked here");
+        Toast toast = Toast.makeText(this, "!!!", Toast.LENGTH_LONG);
+
+
+        if(GameClient.getInstance().getGame().getCurrentState() == GameState.AWAITING_TURN){
+            if(me.getId()==GameClient.getInstance().getGame().getCurrentPlayer().getId()){
+               toast = Toast.makeText(this, "Your Turn!", Toast.LENGTH_LONG);
+            } else {
+                showDialogeWait();
+                toast = Toast.makeText(this, "Player is making a turn!", Toast.LENGTH_LONG);
+            }
+        } else if(GameClient.getInstance().getGame().getCurrentState() == GameState.AWAITING_DECISION){
+            if(me.getId()!=GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getId()){
+                toast = Toast.makeText(this, "Waiting for a decision!", Toast.LENGTH_LONG);
                 showDialogeWait();
-            }
-
-            //Turn wurde ausgeführt und me wurde als Enemy ausgewählt
-            if(GameClient.getInstance().getGame().getCurrentState() == GameState.AWAITING_DECISION && !GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getID().equals(me.getID())){
-                Log.debug("Current Player: " + GameClient.getInstance().getGame().getCurrentPlayer().getName());
-                Log.debug("Current Enems: " + GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getName());
-                Log.debug("You have to make a decission!");
+            } else if(me.getId()==GameClient.getInstance().getGame().getTurn().getSelectedEnemy().getId()){
+                toast = Toast.makeText(this, "Make a decision!", Toast.LENGTH_LONG);
                 showDialogeChallenge();
+            }
+        } else if (GameClient.getInstance().getGame().getCurrentState() == GameState.GAME_OVER) {
+            Log.info("Game ist over!");
+            toast = Toast.makeText(this, "Game is over!", Toast.LENGTH_LONG);
+            showDialogeGameOver();
+
+
+        } else  toast = Toast.makeText(this, "unclear state!", Toast.LENGTH_LONG);
+
+        toast.show();
+
+    }
+
+    public void setUpTypesSpinner(View view) {
+        types = (Spinner) view.findViewById(R.id.spinnerType);
+        typeList = new ArrayList<>();
+        typeList.addAll(Arrays.asList(Type.values()));
+        ArrayAdapter typAdapter = new ArrayAdapter(PlayerIngameMainActivity.this, android.R.layout.simple_spinner_dropdown_item, typeList);
+        types.setAdapter(typAdapter);
+    }
+
+    public void initializeDialogs(){
+        initializeWaitingDialog();
+        initializeChallengeDialog();
+        initializeGameOverDialog();
+    }
+
+    public void initializeWaitingDialog(){
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        View view = View.inflate(this, R.layout.waiting_dialoge, null);
+        builder.setView(view);
+        alertDialog = builder.create();
+        alertDialog.setCancelable(false);
+        waitingDialogTextView = view.findViewById(R.id.notYoutTurn);
+
+    }
+
+    public void initializeChallengeDialog(){
+
+    }
+
+    public void initializeGameOverDialog(){
+
+    }
+
+
+    class StateListenerImpl extends StateListener {
+
+        @Override
+        public void inform() {
+            runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (GameClient.getInstance().getGame().checkRoundOver()) {
+                        GameClient.getInstance().getGame().resetPlayerStatus();
+                    }
+
+                    diaDecision.dismiss();
+                    //diaWait.dismiss();
+                    if(alertDialog !=null)alertDialog.hide();
+
+                    displayCardAmounts();
+                    checkTurn();
+
+                }
+            });
+
+        }
+    }
+
+    //Methoden für das Verwenden des Shakes und des Cheats
+    public void CheckboxClicked(View v) {
+        while(true) {
+            if (((CheckBox) v).isChecked()) {
+                ShakeSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+                accelerometer = ShakeSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+            }
+        }
+    }
+    //Methode für das finden eines Shakes!
+    @Override
+    public void onSensorChanged(SensorEvent e) {
+
+        List changer = new ArrayList();
+
+
+        float x,y,z;
+        x = e.values[0];
+        y = e.values[1];
+        z = e.values[2];
+
+        float Xextract = Math.abs(wert1 - x );
+        float Yextract = Math.abs(wert2 - y );
+        float Zextract = Math.abs(wert3 - z );
+
+        if (Xextract < (float) 0.8) {
+            Xextract = (float) 0.0;
+        }
+
+        if (Yextract < (float) 0.8) {
+            Yextract = (float) 0.0;
+        }
+
+        if (Zextract < (float) 0.8) {
+            Zextract = (float) 0.0;
+        }
+
+        //Zwischenspeicher
+        wert1 = x;
+        wert2 = y;
+        wert3 = z;
+
+        if (Xextract > Yextract) {
+            if(erlaubnis == true){
+                ChangePlayersCollectedDecks();
+            }
+        }
+
+    }
+
+    //tauscht die Collected Karten unter den Spielern
+    public void ChangePlayersCollectedDecks(){
+
+        List changer = new ArrayList();
+
+        Toast.makeText(getApplicationContext(), "Cheat wird ausgeführt!!!", Toast.LENGTH_SHORT).show();
+
+        for (Player player : GameClient.getInstance().getGame().getPlayers()) {
+            changer.add(player.getCollectedDeck().getDeck());
+        }
+
+        Collections.reverse(changer);
+
+        for (Player player : GameClient.getInstance().getGame().getPlayers()) {
+            player.getCollectedDeck().setDeck(changer);
+            changer.remove(0);
+        }
+
+        erlaubnis = false;
+        cheatbox.setVisibility(View.INVISIBLE);
+    }
+
+    //Default methode fürs Handling
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
 
-            }
-        }
+    }
+    //Sollte wieder geschüttelt werden, akitivert sich der Listener
+    @Override
+    protected void onResume() {
+        super.onResume();
+        ShakeSensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);
+    }
+    //Sollte nicht geschüttelt werden, wird der Listerner abgeschalten.
+    @Override
+    protected void onPause() {
+        super.onPause();
+        ShakeSensorManager.unregisterListener(this);
     }
+}
 
 
 
@@ -425,3 +715,5 @@
 
 
 
+
+
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\r\n    <string name=\"app_name\">Kakerlakenpoker</string>\r\n    <string name=\"startbutton\">Search Lobby</string>\r\n    <string name=\"quitbutton\">Create Lobby</string>\r\n    <string name=\"startbackground\">StartBackground</string>\r\n    <string name=\"title_activity_show_lobby\">ShowLobbyActivity</string>\r\n    <!-- Strings used for fragments for navigation -->\r\n    <string name=\"first_fragment_label\">First Fragment</string>\r\n    <string name=\"second_fragment_label\">Second Fragment</string>\r\n    <string name=\"next\">Next</string>\r\n    <string name=\"previous\">Previous</string>\r\n\r\n    <string name=\"hello_first_fragment\">Hello first fragment</string>\r\n    <string name=\"hello_second_fragment\">Hello second fragment. Arg: %1$s</string>\r\n    <string name=\"large_text\">\r\n        \"Material is the metaphor.\\n\\n\"\r\n\r\n        \"A material metaphor is the unifying theory of a rationalized space and a system of motion.\"\r\n        \"The material is grounded in tactile reality, inspired by the study of paper and ink, yet \"\r\n        \"technologically advanced and open to imagination and magic.\\n\"\r\n        \"Surfaces and edges of the material provide visual cues that are grounded in reality. The \"\r\n        \"use of familiar tactile attributes helps users quickly understand affordances. Yet the \"\r\n        \"flexibility of the material creates new affordances that supercede those in the physical \"\r\n        \"world, without breaking the rules of physics.\\n\"\r\n        \"The fundamentals of light, surface, and movement are key to conveying how objects move, \"\r\n        \"interact, and exist in space and in relation to each other. Realistic lighting shows \"\r\n        \"seams, divides space, and indicates moving parts.\\n\\n\"\r\n\r\n        \"Bold, graphic, intentional.\\n\\n\"\r\n\r\n        \"The foundational elements of print based design typography, grids, space, scale, color, \"\r\n        \"and use of imagery guide visual treatments. These elements do far more than please the \"\r\n        \"eye. They create hierarchy, meaning, and focus. Deliberate color choices, edge to edge \"\r\n        \"imagery, large scale typography, and intentional white space create a bold and graphic \"\r\n        \"interface that immerse the user in the experience.\\n\"\r\n        \"An emphasis on user actions makes core functionality immediately apparent and provides \"\r\n        \"waypoints for the user.\\n\\n\"\r\n\r\n        \"Motion provides meaning.\\n\\n\"\r\n\r\n        \"Motion respects and reinforces the user as the prime mover. Primary user actions are \"\r\n        \"inflection points that initiate motion, transforming the whole design.\\n\"\r\n        \"All action takes place in a single environment. Objects are presented to the user without \"\r\n        \"breaking the continuity of experience even as they transform and reorganize.\\n\"\r\n        \"Motion is meaningful and appropriate, serving to focus attention and maintain continuity. \"\r\n        \"Feedback is subtle yet clear. Transitions are efﬁcient yet coherent.\\n\\n\"\r\n\r\n        \"3D world.\\n\\n\"\r\n\r\n        \"The material environment is a 3D space, which means all objects have x, y, and z \"\r\n        \"dimensions. The z-axis is perpendicularly aligned to the plane of the display, with the \"\r\n        \"positive z-axis extending towards the viewer. Every sheet of material occupies a single \"\r\n        \"position along the z-axis and has a standard 1dp thickness.\\n\"\r\n        \"On the web, the z-axis is used for layering and not for perspective. The 3D world is \"\r\n        \"emulated by manipulating the y-axis.\\n\\n\"\r\n\r\n        \"Light and shadow.\\n\\n\"\r\n\r\n        \"Within the material environment, virtual lights illuminate the scene. Key lights create \"\r\n        \"directional shadows, while ambient light creates soft shadows from all angles.\\n\"\r\n        \"Shadows in the material environment are cast by these two light sources. In Android \"\r\n        \"development, shadows occur when light sources are blocked by sheets of material at \"\r\n        \"various positions along the z-axis. On the web, shadows are depicted by manipulating the \"\r\n        \"y-axis only. The following example shows the card with a height of 6dp.\\n\\n\"\r\n\r\n        \"Resting elevation.\\n\\n\"\r\n\r\n        \"All material objects, regardless of size, have a resting elevation, or default elevation \"\r\n        \"that does not change. If an object changes elevation, it should return to its resting \"\r\n        \"elevation as soon as possible.\\n\\n\"\r\n\r\n        \"Component elevations.\\n\\n\"\r\n\r\n        \"The resting elevation for a component type is consistent across apps (e.g., FAB elevation \"\r\n        \"does not vary from 6dp in one app to 16dp in another app).\\n\"\r\n        \"Components may have different resting elevations across platforms, depending on the depth \"\r\n        \"of the environment (e.g., TV has a greater depth than mobile or desktop).\\n\\n\"\r\n\r\n        \"Responsive elevation and dynamic elevation offsets.\\n\\n\"\r\n\r\n        \"Some component types have responsive elevation, meaning they change elevation in response \"\r\n        \"to user input (e.g., normal, focused, and pressed) or system events. These elevation \"\r\n        \"changes are consistently implemented using dynamic elevation offsets.\\n\"\r\n        \"Dynamic elevation offsets are the goal elevation that a component moves towards, relative \"\r\n        \"to the component’s resting state. They ensure that elevation changes are consistent \"\r\n        \"across actions and component types. For example, all components that lift on press have \"\r\n        \"the same elevation change relative to their resting elevation.\\n\"\r\n        \"Once the input event is completed or cancelled, the component will return to its resting \"\r\n        \"elevation.\\n\\n\"\r\n\r\n        \"Avoiding elevation interference.\\n\\n\"\r\n\r\n        \"Components with responsive elevations may encounter other components as they move between \"\r\n        \"their resting elevations and dynamic elevation offsets. Because material cannot pass \"\r\n        \"through other material, components avoid interfering with one another any number of ways, \"\r\n        \"whether on a per component basis or using the entire app layout.\\n\"\r\n        \"On a component level, components can move or be removed before they cause interference. \"\r\n        \"For example, a floating action button (FAB) can disappear or move off screen before a \"\r\n        \"user picks up a card, or it can move if a snackbar appears.\\n\"\r\n        \"On the layout level, design your app layout to minimize opportunities for interference. \"\r\n        \"For example, position the FAB to one side of stream of a cards so the FAB won’t interfere \"\r\n        \"when a user tries to pick up one of cards.\\n\\n\"\r\n    </string>\r\n    <string name=\"action_settings\">Settings</string>\r\n    <string name=\"title_activity_players_in_lobby\">PlayersInLobbyActivity</string>\r\n    <string name=\"title_activity_show_players_in_lobby\">ScrollingActivity</string>\r\n    <string name=\"karte\">Karte</string>\r\n    <string name=\"karte1\">Karte</string>\r\n    <string name=\"truth\">TRUTH</string>\r\n    <string name=\"lie\">LIE</string>\r\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/res/values/strings.xml	(date 1623528549306)
@@ -108,4 +108,5 @@
     <string name="karte1">Karte</string>
     <string name="truth">TRUTH</string>
     <string name="lie">LIE</string>
+    <string name="hand_over">Hand Over</string>
 </resources>
\ No newline at end of file
Index: core/src/main/java/com/example/server/dto/Lobby.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.server.dto;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class Lobby extends BaseMessage{\r\n    private String name;\r\n    private String hostIP;\r\n    private HashMap<String, String> playersIp = new HashMap<>();\r\n\r\n    public Lobby(String name){\r\n        this.name = name;\r\n    }\r\n\r\n    public void setHostIP(String hostIP){\r\n        this.hostIP = hostIP;\r\n    }\r\n\r\n\r\n    public Lobby(){}\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getHostIP() {\r\n        return hostIP;\r\n    }\r\n\r\n    public HashMap<String, String> getPlayersIpList() {\r\n        return playersIp;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Lobby{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", HostIP='\" + hostIP + '\\'' +\r\n                \", playersIpList=\" + playersIp +\r\n                '}';\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- core/src/main/java/com/example/server/dto/Lobby.java	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ core/src/main/java/com/example/server/dto/Lobby.java	(date 1623528549319)
@@ -1,21 +1,18 @@
 package com.example.server.dto;
 
-import java.net.InetSocketAddress;
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
 
 public class Lobby extends BaseMessage{
     private String name;
-    private String hostIP;
+    private String hostId;
     private HashMap<String, String> playersIp = new HashMap<>();
 
     public Lobby(String name){
         this.name = name;
     }
 
-    public void setHostIP(String hostIP){
-        this.hostIP = hostIP;
+    public void setHostId(String hostId){
+        this.hostId = hostId;
     }
 
 
@@ -24,8 +21,8 @@
         return name;
     }
 
-    public String getHostIP() {
-        return hostIP;
+    public String getHostId() {
+        return hostId;
     }
 
     public HashMap<String, String> getPlayersIpList() {
@@ -36,7 +33,7 @@
     public String toString() {
         return "Lobby{" +
                 "name='" + name + '\'' +
-                ", HostIP='" + hostIP + '\'' +
+                ", HostIP='" + hostId + '\'' +
                 ", playersIpList=" + playersIp +
                 '}';
     }
Index: app/src/main/res/layout/decision_dialoge.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n\r\n</androidx.constraintlayout.widget.ConstraintLayout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/decision_dialoge.xml	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/res/layout/decision_dialoge.xml	(date 1623528549304)
@@ -1,6 +1,69 @@
 <?xml version="1.0" encoding="utf-8"?>
 <androidx.constraintlayout.widget.ConstraintLayout
-    xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
     android:layout_height="match_parent">
 
+    <TextView
+        android:id="@+id/info"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="TextView"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintBottom_toBottomOf="@id/truth"
+        app:layout_constraintTop_toTopOf="parent" />
+
+    <Button
+        android:id="@+id/truth"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/truth"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintBottom_toTopOf="@id/lie"
+        app:layout_constraintTop_toBottomOf="@id/info" />
+
+    <Button
+        android:id="@+id/lie"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/lie"
+        app:layout_constraintBottom_toTopOf="@+id/handOver"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/truth" />
+
+    <Spinner
+        android:id="@+id/handOver"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@+id/handOverButton"
+        app:layout_constraintStart_toEndOf="@id/spinnerType"
+        app:layout_constraintTop_toBottomOf="@id/lie" />
+
+    <Button
+        android:id="@+id/handOverButton"
+        android:layout_width="wrap_content"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_height="wrap_content"
+        android:text="@string/hand_over"
+        app:layout_constraintTop_toBottomOf="@id/lie"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toEndOf="@id/handOver"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <Spinner
+        android:id="@+id/spinnerType"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@+id/handOver"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@+id/lie" />
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
Index: core/src/main/java/com/example/server/network/dto/clienttogameserver/HandOver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- core/src/main/java/com/example/server/network/dto/clienttogameserver/HandOver.java	(date 1623528549320)
+++ core/src/main/java/com/example/server/network/dto/clienttogameserver/HandOver.java	(date 1623528549320)
@@ -0,0 +1,25 @@
+package com.example.server.network.dto.clienttogameserver;
+
+import com.example.game.Decision;
+import com.example.game.player.Player;
+
+public class HandOver {
+    private Player enemy;
+    private Decision decision;
+    public HandOver(){
+
+    }
+
+    public HandOver(Player enemy, Decision decision){
+        this.enemy = enemy;
+        this.decision = decision;
+    }
+
+    public Decision getDecision() {
+        return decision;
+    }
+
+    public Player getEnemy() {
+        return enemy;
+    }
+}
Index: app/src/main/res/layout-land/decision_dialoge.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<androidx.constraintlayout.widget.ConstraintLayout\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\">\r\n\r\n    <TextView\r\n        android:id=\"@+id/info\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"TextView\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintBottom_toBottomOf=\"@id/truth\"\r\n        app:layout_constraintTop_toTopOf=\"parent\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/truth\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"@string/truth\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\"\r\n        app:layout_constraintBottom_toTopOf=\"@id/lie\"\r\n       app:layout_constraintTop_toBottomOf=\"@id/info\" />\r\n\r\n    <Button\r\n        android:id=\"@+id/lie\"\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"@string/lie\"\r\n        app:layout_constraintTop_toBottomOf=\"@id/truth\"\r\n        app:layout_constraintBottom_toBottomOf=\"parent\"\r\n        app:layout_constraintEnd_toEndOf=\"parent\"\r\n        app:layout_constraintStart_toStartOf=\"parent\" />\r\n</androidx.constraintlayout.widget.ConstraintLayout>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout-land/decision_dialoge.xml	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/res/layout-land/decision_dialoge.xml	(date 1623528549301)
@@ -31,8 +31,39 @@
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:text="@string/lie"
-        app:layout_constraintTop_toBottomOf="@id/truth"
-        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintBottom_toTopOf="@+id/handOver"
         app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent" />
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/truth" />
+
+    <Spinner
+        android:id="@+id/handOver"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@+id/handOverButton"
+        app:layout_constraintStart_toEndOf="@id/spinnerType"
+        app:layout_constraintTop_toBottomOf="@id/lie" />
+
+    <Button
+        android:id="@+id/handOverButton"
+        android:layout_width="wrap_content"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_height="wrap_content"
+        android:text="@string/hand_over"
+        app:layout_constraintTop_toBottomOf="@id/lie"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toEndOf="@id/handOver"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <Spinner
+        android:id="@+id/spinnerType"
+        app:layout_constraintHorizontal_chainStyle="packed"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toStartOf="@+id/handOver"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@+id/lie" />
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
Index: app/src/main/java/com/example/kakerlakenpoker/activities/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kakerlakenpoker.activities;\r\n\r\nimport com.example.game.card.Card;\r\nimport com.example.game.card.Type;\r\nimport com.example.game.BuildGame;\r\nimport com.example.game.Decision;\r\nimport com.example.game.Game;\r\nimport com.example.game.Turn;\r\nimport com.example.game.player.CollectedDeck;\r\nimport com.example.game.player.HandDeck;\r\nimport com.example.game.player.Player;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        Player player1 = new Player(1, new HandDeck(), new CollectedDeck());\r\n        Player player2 = new Player(2, new HandDeck(), new CollectedDeck());\r\n        Player player3 = new Player(3, new HandDeck(), new CollectedDeck());\r\n        Player player4 = new Player(4, new HandDeck(), new CollectedDeck());\r\n        ArrayList<Player> player = new ArrayList<>();\r\n        player.add(player1);\r\n        player.add(player2);\r\n        player.add(player3);\r\n        player.add(player4);\r\n        boolean next = true;\r\n        int round = 1;\r\n        boolean displ = true;\r\n        Card currCard;\r\n        String card = \"x\";\r\n        String enemy;\r\n        String say;\r\n        String decission;\r\n        List<Player> possible;\r\n        Scanner scanner = new Scanner(System.in);\r\n        BuildGame buildGame = new BuildGame();\r\n        buildGame.setPlayers(player);\r\n        Game game = buildGame.buildGame();\r\n        game.setCurrentPlayer(game.getPlayerbyName(\"player1\"));\r\n        System.out.println(\"Game build success!\");\r\n\r\n            while (next) {\r\n                next = false;\r\n                if(game.getCurrentPlayer().getCollectedDeck().hasLost()){\r\n<<<<<<< HEAD\r\n                    System.out.println(\"Player \" + game.getCurrentPlayer().getID() +\" lost the game!\");\r\n=======\r\n                    System.out.println(\"Player \" + game.getCurrentPlayer().getId() +\" lost the game!\");\r\n>>>>>>> reorderingFiles\r\n                    System.out.println(game.getCurrentPlayer().getCollectedDeck().showAllCards().toString());\r\n                    break;\r\n                }\r\n                System.out.println(\"####ROUND \" + round + \"#####\");\r\n                game.resetPlayerStatus();\r\n                int local = round;\r\n<<<<<<< HEAD\r\n                System.out.println(\"Turn of player: \" + game.getCurrentPlayer().getID());\r\n=======\r\n                System.out.println(\"Turn of player: \" + game.getCurrentPlayer().getId());\r\n>>>>>>> reorderingFiles\r\n                while (displ) {\r\n                    System.out.println(\"Your Handcards are: \" + game.getCurrentPlayer().getHandDeck().showAllCards().toString());\r\n                    System.out.println(\"Choose a Card to play or enter display to see the collected Cards of your enemys: \");\r\n                    card = scanner.nextLine();\r\n                    if (card.equals(\"display\")) {\r\n                        for (Player p : player) {\r\n                            System.out.println(\"---------------------------------\");\r\n<<<<<<< HEAD\r\n                            System.out.println(\"Collectded Deck of player: \" + p.getID());\r\n=======\r\n                            System.out.println(\"Collectded Deck of player: \" + p.getId());\r\n>>>>>>> reorderingFiles\r\n                            System.out.println(p.getCollectedDeck().showAllCards().toString());\r\n                            System.out.println();\r\n                        }\r\n                    } else {\r\n                        displ = false;\r\n                    }\r\n                }\r\n                displ = true;\r\n                currCard = game.getCurrentPlayer().getHandDeck().findCard(card);\r\n                game.getCurrentPlayer().getHandDeck().removeCard(currCard);\r\n                System.out.println(\"You choose: \" + currCard.getType().toString());\r\n                while (local == round) {\r\n<<<<<<< HEAD\r\n                    System.out.println(\"Current Player: \" + game.getCurrentPlayer().getID());\r\n=======\r\n                    System.out.println(\"Current Player: \" + game.getCurrentPlayer().getId());\r\n>>>>>>> reorderingFiles\r\n                    System.out.println();\r\n                    System.out.println(\"Possible Enemys: \" );\r\n                    possible = game.getAvailablePlayer();\r\n                    for (Player p: possible) {\r\n<<<<<<< HEAD\r\n                        if(!p.getID().equals(game.getCurrentPlayer().getID())){\r\n                        System.out.println(\"Player: \" + p.getID());\r\n=======\r\n                        if(p.getId()!=(game.getCurrentPlayer().getId())){\r\n                        System.out.println(\"Player: \" + p.getId());\r\n>>>>>>> reorderingFiles\r\n                        }\r\n                    }\r\n                    System.out.println();\r\n                    System.out.println(\"Choose an Enemy: \");\r\n                    enemy = scanner.nextLine();\r\n                    System.out.println(\"You choose: \" + enemy);\r\n                    System.out.println(\"What do you say to your enemy? \");\r\n                    say = scanner.nextLine();\r\n                    game.makeTurn(game.getCurrentPlayer(), new Turn(currCard, Type.valueOf(say), game.getPlayerbyName(enemy)));\r\n<<<<<<< HEAD\r\n                    System.out.println(enemy + \": \"  + game.getCurrentPlayer().getID() + \" played \" + say + \"!\");\r\n=======\r\n                    System.out.println(enemy + \": \"  + game.getCurrentPlayer().getId() + \" played \" + say + \"!\");\r\n>>>>>>> reorderingFiles\r\n                    System.out.println(\"Enter decision or reject!\");\r\n                    decission = scanner.nextLine();\r\n\r\n                    if (decission.equals(\"decision\")) {\r\n                        System.out.println(\"Enter TRUTH or LIE\");\r\n<<<<<<< HEAD\r\n                        String printer = game.getCurrentPlayer().getID();\r\n=======\r\n                        int printer = game.getCurrentPlayer().getId();\r\n>>>>>>> reorderingFiles\r\n                        decission = scanner.nextLine();\r\n                        game.makeDecision(game.getPlayerbyName(enemy), Decision.valueOf(decission));\r\n                        System.out.println(\"---------CHALLENGE---------\");\r\n                        System.out.println(printer + \" played \" + card + \" and said \" + say);\r\n                        System.out.println(enemy + \" said \" + decission);\r\n<<<<<<< HEAD\r\n                        System.out.println(\"New curr Player: = \" + game.getCurrentPlayer().getID());\r\n                        next = true;\r\n                        round++;\r\n                    } else if (decission.equals(\"reject\")) {\r\n                        System.out.println(\"Player \" + game.getCurrentPlayer().getID() + \" played: \" + card);\r\n=======\r\n                        System.out.println(\"New curr Player: = \" + game.getCurrentPlayer().getId());\r\n                        next = true;\r\n                        round++;\r\n                    } else if (decission.equals(\"reject\")) {\r\n                        System.out.println(\"Player \" + game.getCurrentPlayer().getId() + \" played: \" + card);\r\n>>>>>>> reorderingFiles\r\n                        game.reject(game.getPlayerbyName(enemy));\r\n                        System.out.println();\r\n                    }\r\n                    if (game.checkRoundOver()) {\r\n                        next = true;\r\n                        round++;\r\n                    }\r\n                }\r\n\r\n                System.out.println();\r\n\r\n            }\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/kakerlakenpoker/activities/Test.java	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/java/com/example/kakerlakenpoker/activities/Test.java	(date 1623529225821)
@@ -15,6 +15,7 @@
 import java.util.Scanner;
 
 public class Test {
+    /*
     public static void main(String[] args) {
         Player player1 = new Player(1, new HandDeck(), new CollectedDeck());
         Player player2 = new Player(2, new HandDeck(), new CollectedDeck());
@@ -45,10 +46,10 @@
                 next = false;
                 if(game.getCurrentPlayer().getCollectedDeck().hasLost()){
 <<<<<<< HEAD
+                    System.out.println("Player " + game.getCurrentPlayer().getId() +" lost the game!");
+=======
                     System.out.println("Player " + game.getCurrentPlayer().getID() +" lost the game!");
-=======
-                    System.out.println("Player " + game.getCurrentPlayer().getId() +" lost the game!");
->>>>>>> reorderingFiles
+>>>>>>> origin/develop
                     System.out.println(game.getCurrentPlayer().getCollectedDeck().showAllCards().toString());
                     break;
                 }
@@ -56,10 +57,10 @@
                 game.resetPlayerStatus();
                 int local = round;
 <<<<<<< HEAD
-                System.out.println("Turn of player: " + game.getCurrentPlayer().getID());
+                System.out.println("Turn of player: " + game.getCurrentPlayer().getId());
 =======
-                System.out.println("Turn of player: " + game.getCurrentPlayer().getId());
->>>>>>> reorderingFiles
+                System.out.println("Turn of player: " + game.getCurrentPlayer().getID());
+>>>>>>> origin/develop
                 while (displ) {
                     System.out.println("Your Handcards are: " + game.getCurrentPlayer().getHandDeck().showAllCards().toString());
                     System.out.println("Choose a Card to play or enter display to see the collected Cards of your enemys: ");
@@ -68,10 +69,10 @@
                         for (Player p : player) {
                             System.out.println("---------------------------------");
 <<<<<<< HEAD
+                            System.out.println("Collectded Deck of player: " + p.getId());
+=======
                             System.out.println("Collectded Deck of player: " + p.getID());
-=======
-                            System.out.println("Collectded Deck of player: " + p.getId());
->>>>>>> reorderingFiles
+>>>>>>> origin/develop
                             System.out.println(p.getCollectedDeck().showAllCards().toString());
                             System.out.println();
                         }
@@ -85,21 +86,21 @@
                 System.out.println("You choose: " + currCard.getType().toString());
                 while (local == round) {
 <<<<<<< HEAD
-                    System.out.println("Current Player: " + game.getCurrentPlayer().getID());
+                    System.out.println("Current Player: " + game.getCurrentPlayer().getId());
 =======
-                    System.out.println("Current Player: " + game.getCurrentPlayer().getId());
->>>>>>> reorderingFiles
+                    System.out.println("Current Player: " + game.getCurrentPlayer().getID());
+>>>>>>> origin/develop
                     System.out.println();
                     System.out.println("Possible Enemys: " );
                     possible = game.getAvailablePlayer();
                     for (Player p: possible) {
 <<<<<<< HEAD
-                        if(!p.getID().equals(game.getCurrentPlayer().getID())){
-                        System.out.println("Player: " + p.getID());
-=======
                         if(p.getId()!=(game.getCurrentPlayer().getId())){
                         System.out.println("Player: " + p.getId());
->>>>>>> reorderingFiles
+=======
+                        if(!p.getID().equals(game.getCurrentPlayer().getID())){
+                        System.out.println("Player: " + p.getID());
+>>>>>>> origin/develop
                         }
                     }
                     System.out.println();
@@ -110,38 +111,38 @@
                     say = scanner.nextLine();
                     game.makeTurn(game.getCurrentPlayer(), new Turn(currCard, Type.valueOf(say), game.getPlayerbyName(enemy)));
 <<<<<<< HEAD
-                    System.out.println(enemy + ": "  + game.getCurrentPlayer().getID() + " played " + say + "!");
-=======
                     System.out.println(enemy + ": "  + game.getCurrentPlayer().getId() + " played " + say + "!");
->>>>>>> reorderingFiles
+=======
+                    System.out.println(enemy + ": "  + game.getCurrentPlayer().getID() + " played " + say + "!");
+>>>>>>> origin/develop
                     System.out.println("Enter decision or reject!");
                     decission = scanner.nextLine();
 
                     if (decission.equals("decision")) {
                         System.out.println("Enter TRUTH or LIE");
 <<<<<<< HEAD
-                        String printer = game.getCurrentPlayer().getID();
+                        int printer = game.getCurrentPlayer().getId();
 =======
-                        int printer = game.getCurrentPlayer().getId();
->>>>>>> reorderingFiles
+                        String printer = game.getCurrentPlayer().getID();
+>>>>>>> origin/develop
                         decission = scanner.nextLine();
                         game.makeDecision(game.getPlayerbyName(enemy), Decision.valueOf(decission));
                         System.out.println("---------CHALLENGE---------");
                         System.out.println(printer + " played " + card + " and said " + say);
                         System.out.println(enemy + " said " + decission);
 <<<<<<< HEAD
-                        System.out.println("New curr Player: = " + game.getCurrentPlayer().getID());
+                        System.out.println("New curr Player: = " + game.getCurrentPlayer().getId());
                         next = true;
                         round++;
                     } else if (decission.equals("reject")) {
-                        System.out.println("Player " + game.getCurrentPlayer().getID() + " played: " + card);
+                        System.out.println("Player " + game.getCurrentPlayer().getId() + " played: " + card);
 =======
-                        System.out.println("New curr Player: = " + game.getCurrentPlayer().getId());
+                        System.out.println("New curr Player: = " + game.getCurrentPlayer().getID());
                         next = true;
                         round++;
                     } else if (decission.equals("reject")) {
-                        System.out.println("Player " + game.getCurrentPlayer().getId() + " played: " + card);
->>>>>>> reorderingFiles
+                        System.out.println("Player " + game.getCurrentPlayer().getID() + " played: " + card);
+>>>>>>> origin/develop
                         game.reject(game.getPlayerbyName(enemy));
                         System.out.println();
                     }
@@ -155,5 +156,6 @@
 
             }
     }
+    */
 }
 
Index: .github/workflows/github-actions-demo.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .github/workflows/github-actions-demo.yml	(date 1623528549281)
+++ .github/workflows/github-actions-demo.yml	(date 1623528549281)
@@ -0,0 +1,17 @@
+name: GitHub Actions Demo
+on: [push]
+jobs:
+  Explore-GitHub-Actions:
+    runs-on: ubuntu-latest
+    steps:
+      - run: echo "🎉 The job was automatically triggered by a ${{ github.event_name }} event."
+      - run: echo "🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!"
+      - run: echo "🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
+      - name: Check out repository code
+        uses: actions/checkout@v2
+      - run: echo "💡 The ${{ github.repository }} repository has been cloned to the runner."
+      - run: echo "🖥️ The workflow is now ready to test your code on the runner."
+      - name: List files in the repository
+        run: |
+          ls ${{ github.workspace }}
+      - run: echo "🍏 This job's status is ${{ job.status }}."
\ No newline at end of file
Index: app/src/main/java/com/example/kakerlakenpoker/activities/GameListenerClientSide.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kakerlakenpoker.activities;\r\n\r\nimport com.example.game.GameState;\r\nimport com.example.game.listener.GameListener;\r\nimport com.example.server.network.dto.gameservertoclient.GameOver;\r\nimport com.example.server.network.dto.gameservertoclient.GameUpdate;\r\nimport com.example.server.network.dto.clienttogameserver.MakeDecision;\r\nimport com.example.server.network.dto.clienttogameserver.MakeTurn;\r\n\r\n\r\npublic class GameListenerClientSide implements GameListener {\r\n    private GameClient gameClient;\r\n\r\n    public GameListenerClientSide(GameClient client){\r\n        gameClient = client;\r\n    }\r\n    @Override\r\n    public void notify(GameUpdate gameUpdate, GameState previousState) {\r\n        if(previousState==GameState.AWAITING_TURN && gameUpdate.getState()==GameState.AWAITING_DECISION)\r\n        gameClient.getClient().sendMessage(new MakeTurn(gameUpdate.getTurn()));\r\n        else if(previousState==GameState.AWAITING_DECISION && gameUpdate.getState()==GameState.AWAITING_TURN)\r\n            gameClient.getClient().sendMessage(new MakeDecision(gameUpdate.getDecision()));\r\n        else if(gameUpdate.getState() ==GameState.GAME_OVER)gameClient.getClient().sendMessage(new GameOver());\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/kakerlakenpoker/activities/GameListenerClientSide.java	(revision 4c95f02c0f317c55af62ebb2230dc5850e9dd0e3)
+++ app/src/main/java/com/example/kakerlakenpoker/activities/GameListenerClientSide.java	(date 1623528549285)
@@ -20,6 +20,6 @@
         gameClient.getClient().sendMessage(new MakeTurn(gameUpdate.getTurn()));
         else if(previousState==GameState.AWAITING_DECISION && gameUpdate.getState()==GameState.AWAITING_TURN)
             gameClient.getClient().sendMessage(new MakeDecision(gameUpdate.getDecision()));
-        else if(gameUpdate.getState() ==GameState.GAME_OVER)gameClient.getClient().sendMessage(new GameOver());
+        else if(gameUpdate.getState() ==GameState.GAME_OVER)gameClient.getClient().sendMessage(new MakeDecision(gameUpdate.getDecision()));
     }
 }
